// 배열 개념
const arr1 = new Array(6);
const arr2 = [...new Array(6)].map((_, i) => i + 1);

const arr = new Array(6).fill(0);
const arr3 = [...new Array(4)].map((_,i) => new Array(4).fill(i));

/**배열 연산의 시간 복잡도
 * 배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 단 한 번에 접근할 수 있다. 
 * 따라서 데이터에 접근하기 위한 시간 복자도는 O(1).
 * 배열에 데이터를 추가하는 경우에는 배열은 데이터를 어디에 저장하느냐에 따라 추가 연산에 대한 시간 복잡도가 달라진다.
 * 
 * 맨 뒤에 삽입할 경우 arr[3]에 임의 접근으 ㄹ바로 할 수 있으며 데이터를 삽입해도 다른 데이터 위치에 영향을 주지 않습니다. 따라서 시간 복잡도는 O(1)입니다.
 * 
 * 배열을 선택할 때 고려할 점
 * 데이터에 자주 접근하거나 읽어야하는 경우 배열을 사용하면 좋은 성능을 낼 수 있습니다.
 * 예를 들어 그래프를 표현할 때 임의 접근을 할 수 있으므로 간선 여부도 시간 복잡도 O(1)로 판단할 수 있습니다. 
 * 하지만 배열은 메모리 공간을 충분히 확보해야하는 단점도 있습니다.
 * 
 * 따라서 코딩 테스트에서는 다음 사항을 고려해 배열을 선택해야합니다.
 * 1. 할당할 수 있는 메모리 크기를 확인해야 합니다.
 * 배열로 표현하려는 데이터가 너무 많으면 런타임에서 배열할당에 실패할 수 있습니다. 운영체제마다 배열을 할당할 수 있는 메모리의 한계치는 다르지만  보통은 정수형 1차원 배열은 1000만 개, 2차원 배열은 3000*3000 크기를 최대로 생각합니다.
 * 2. 중간에 데이터 삽입이 많은지 확인해야 합니다.
 * 배열은 선형 자료 구조이기 때문에 중간이나 처음에 데이터를 빈번하게 삽입하면 시간 복잡도가 높아져 실제 시험에서 시간 초과가 발생할 수 있습니다.
*/

/** 스프레드 연산자로 데이터 추가 */
let spreadArr = [1,2,3];
spreadArr = [...spreadArr, ...[4, 5]];

// unshift() 메서드로 데이터 추가
const unshiftArr = [1, 2, 3];
unshiftArr.unshift(0);

// splice() 메서드로 데이터 추가
// 배열 중간에 데이터를 추가하기 위해서는 splice() 메서드를 사용해야 합니다. 
// array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
// 첫번째 매개변수 start 는 배열 내 시작 지점을 의미합니다. 두번째 매개변수 deleteCount는 삭제할 데이터의 수를 의미하고
// 이후로는 추가할 데이터를 받습니다. 
// 이를 이용하여 두번째 매개변수를 0으로 설정하면 다음과 같이 중간에 데이터를 추가할 수 있습니다. 
/// 대괄호로 감싸지 않은 첫번째 매개변수는 꼭 필요한 값이고, 대괄호로 감싼 매개변수는 선택 optional 매개변수입니다.
//