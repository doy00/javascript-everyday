// 배열 개념
const arr1 = new Array(6);
const arr2 = [...new Array(6)].map((_, i) => i + 1);

const arr = new Array(6).fill(0);
const arr3 = [...new Array(4)].map((_,i) => new Array(4).fill(i));

/**배열 연산의 시간 복잡도
 * 배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 단 한 번에 접근할 수 있다. 
 * 따라서 데이터에 접근하기 위한 시간 복자도는 O(1).
 * 배열에 데이터를 추가하는 경우에는 배열은 데이터를 어디에 저장하느냐에 따라 추가 연산에 대한 시간 복잡도가 달라진다.
 * 
 * 맨 뒤에 삽입할 경우 arr[3]에 임의 접근으 ㄹ바로 할 수 있으며 데이터를 삽입해도 다른 데이터 위치에 영향을 주지 않습니다. 따라서 시간 복잡도는 O(1)입니다.
 * 
 * 배열을 선택할 때 고려할 점
 * 데이터에 자주 접근하거나 읽어야하는 경우 배열을 사용하면 좋은 성능을 낼 수 있습니다.
 * 예를 들어 그래프를 표현할 때 임의 접근을 할 수 있으므로 간선 여부도 시간 복잡도 O(1)로 판단할 수 있습니다. 
 * 하지만 배열은 메모리 공간을 충분히 확보해야하는 단점도 있습니다.
 * 
 * 따라서 코딩 테스트에서는 다음 사항을 고려해 배열을 선택해야합니다.
 * 1. 할당할 수 있는 메모리 크기를 확인해야 합니다.
 * 배열로 표현하려는 데이터가 너무 많으면 런타임에서 배열할당에 실패할 수 있습니다. 운영체제마다 배열을 할당할 수 있는 메모리의 한계치는 다르지만  보통은 정수형 1차원 배열은 1000만 개, 2차원 배열은 3000*3000 크기를 최대로 생각합니다.
 * 2. 중간에 데이터 삽입이 많은지 확인해야 합니다.
 * 배열은 선형 자료 구조이기 때문에 중간이나 처음에 데이터를 빈번하게 삽입하면 시간 복잡도가 높아져 실제 시험에서 시간 초과가 발생할 수 있습니다.
*/

/** 스프레드 연산자로 데이터 추가 */
let spreadArr = [1,2,3];
spreadArr = [...spreadArr, ...[4, 5]];

// unshift() 메서드로 데이터 추가
const unshiftArr = [1, 2, 3];
unshiftArr.unshift(0);

// splice() 메서드로 데이터 추가
// 배열 중간에 데이터를 추가하기 위해서는 splice() 메서드를 사용해야 합니다. 
// array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
// 첫번째 매개변수 start 는 배열 내 시작 지점을 의미합니다. 두번째 매개변수 deleteCount는 삭제할 데이터의 수를 의미하고
// 이후로는 추가할 데이터를 받습니다. 
// 이를 이용하여 두번째 매개변수를 0으로 설정하면 다음과 같이 중간에 데이터를 추가할 수 있습니다. 
/// 대괄호로 감싸지 않은 첫번째 매개변수는 꼭 필요한 값이고, 대괄호로 감싼 매개변수는 선택 optional 매개변수입니다.
//

// 배열 몸풀기 문제 - 배열 정렬하기
// 권장 시간 복잡도 O(NlogN)
// 정수 배열의 길이는 2 이상 10^5 이하입니다.
// 정수 배열의 각 데이터 값은 -100,000 이상 100,000 이하입니다.
// 문제만 놓고 보면 가단해 보이지만 제약 조건을 주의 깊게 봐야합니다. 제약 조건을 보면 데이터 개수는 최대 10^%입니다.
// 즉, 제한 시간이 3초라면 O(N^2) 알고리즘을 사용해도 되죠. 제가 이 문제를 제시한 이유는 제약 조건에 따른 알고리즘의 선택을 보여주기 위함입니다. 

function solution(arr) {
  arr.sort((a, b) => a - b);
  return arr;
}
// 첫번째 인자 a가 두번째 인자 b보다 앞에 나와야 한다면 음수를 반환한다.
// 첫번째 인자 a가 두번째 인자 b보다 뒤에 나와야 한다면 양수를 반환한다.
// 3. 위치 변경을 하지 않는다면 0을 반환한다.

// 먼저 기준은 첫번째 인수라는 점을 이용할 수 있습니다. 따라서 첫번째 인자를 a, 두번째 인자를 b라고 부를때 
// a에서 b를 빼는 식을 사용한다면 a가 b보다 큰 경우 자연스럽게 양수가 반환되고 작은 경우엔 음수가 ㅏㄴ환됩니다.
// 만약 반대로 내림차순으로 정렬한다면 두번째 인자에서 첫번째 인자를 빼도록 만들면 됩니다.
// 참고로 sort() 메서드를 사용하면 기존 ㅐ열이 변경됩니다. 원본 배열을 그대로 두고 싶다면 toSorted() 메서드를 사용할 수도 있지만 비교적 최근에 추가된 기능이므로 sort() 메서드 사용을 추천합니다.