// 배열 개념
const arr1 = new Array(6);
const arr2 = [...new Array(6)].map((_, i) => i + 1);

const arr = new Array(6).fill(0);
const arr3 = [...new Array(4)].map((_,i) => new Array(4).fill(i));

/**배열 연산의 시간 복잡도
 * 배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 단 한 번에 접근할 수 있다. 
 * 따라서 데이터에 접근하기 위한 시간 복자도는 O(1).
 * 배열에 데이터를 추가하는 경우에는 배열은 데이터를 어디에 저장하느냐에 따라 추가 연산에 대한 시간 복잡도가 달라진다.
 * 
 * 맨 뒤에 삽입할 경우 arr[3]에 임의 접근으 ㄹ바로 할 수 있으며 데이터를 삽입해도 다른 데이터 위치에 영향을 주지 않습니다. 따라서 시간 복잡도는 O(1)입니다.
 * 
 * 배열을 선택할 때 고려할 점
 * 데이터에 자주 접근하거나 읽어야하는 경우 배열을 사용하면 좋은 성능을 낼 수 있습니다.
 * 예를 들어 그래프를 표현할 때 임의 접근을 할 수 있으므로 간선 여부도 시간 복잡도 O(1)로 판단할 수 있습니다. 
 * 하지만 배열은 메모리 공간을 충분히 확보해야하는 단점도 있습니다.
 * 
 * 따라서 코딩 테스트에서는 다음 사항을 고려해 배열을 선택해야합니다.
 * 1. 할당할 수 있는 메모리 크기를 확인해야 합니다.
 * 배열로 표현하려는 데이터가 너무 많으면 런타임에서 배열할당에 실패할 수 있습니다. 운영체제마다 배열을 할당할 수 있는 메모리의 한계치는 다르지만  보통은 정수형 1차원 배열은 1000만 개, 2차원 배열은 3000*3000 크기를 최대로 생각합니다.
 * 2. 중간에 데이터 삽입이 많은지 확인해야 합니다.
 * 배열은 선형 자료 구조이기 때문에 중간이나 처음에 데이터를 빈번하게 삽입하면 시간 복잡도가 높아져 실제 시험에서 시간 초과가 발생할 수 있습니다.
*/

/** 스프레드 연산자로 데이터 추가 */
let spreadArr = [1,2,3];
spreadArr = [...spreadArr, ...[4, 5]];

// unshift() 메서드로 데이터 추가
const unshiftArr = [1, 2, 3];
unshiftArr.unshift(0);

// splice() 메서드로 데이터 추가
// 배열 중간에 데이터를 추가하기 위해서는 splice() 메서드를 사용해야 합니다. 
// array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
// 첫번째 매개변수 start 는 배열 내 시작 지점을 의미합니다. 두번째 매개변수 deleteCount는 삭제할 데이터의 수를 의미하고
// 이후로는 추가할 데이터를 받습니다. 
// 이를 이용하여 두번째 매개변수를 0으로 설정하면 다음과 같이 중간에 데이터를 추가할 수 있습니다. 
/// 대괄호로 감싸지 않은 첫번째 매개변수는 꼭 필요한 값이고, 대괄호로 감싼 매개변수는 선택 optional 매개변수입니다.
//

// 배열 몸풀기 문제 - 배열 정렬하기
// 권장 시간 복잡도 O(NlogN)
// 정수 배열의 길이는 2 이상 10^5 이하입니다.
// 정수 배열의 각 데이터 값은 -100,000 이상 100,000 이하입니다.
// 문제만 놓고 보면 가단해 보이지만 제약 조건을 주의 깊게 봐야합니다. 제약 조건을 보면 데이터 개수는 최대 10^%입니다.
// 즉, 제한 시간이 3초라면 O(N^2) 알고리즘을 사용해도 되죠. 제가 이 문제를 제시한 이유는 제약 조건에 따른 알고리즘의 선택을 보여주기 위함입니다. 

function solution(arr) {
  arr.sort((a, b) => a - b);
  return arr;
}
// 첫번째 인자 a가 두번째 인자 b보다 앞에 나와야 한다면 음수를 반환한다.
// 첫번째 인자 a가 두번째 인자 b보다 뒤에 나와야 한다면 양수를 반환한다.
// 3. 위치 변경을 하지 않는다면 0을 반환한다.

// 먼저 기준은 첫번째 인수라는 점을 이용할 수 있습니다. 따라서 첫번째 인자를 a, 두번째 인자를 b라고 부를때 
// a에서 b를 빼는 식을 사용한다면 a가 b보다 큰 경우 자연스럽게 양수가 반환되고 작은 경우엔 음수가 ㅏㄴ환됩니다.
// 만약 반대로 내림차순으로 정렬한다면 두번째 인자에서 첫번째 인자를 빼도록 만들면 됩니다.
// 참고로 sort() 메서드를 사용하면 기존 ㅐ열이 변경됩니다. 원본 배열을 그대로 두고 싶다면 toSorted() 메서드를 사용할 수도 있지만 비교적 최근에 추가된 기능이므로 sort() 메서드 사용을 추천합니다.

// sort() 메서드를 사용하지 않고 O(N^2) 정렬 알고리즘을 사용하면?
function bubbleSort(arr) { // 버블 정렬을 활용한 방법
  const n = arr.length;
  for (let i = 0; i < n; i++){
    for (let j = 0; j < n - i - 1; j++){
      if (arr[j + 1] < arr[j]) {
        const tmp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = tmp;
      }
    }
  }
  return arr;
}

function doSort(arr) {  // sort() 함수를 활용한 방법
  arr.sort((a, b) => a - b);
  return arr;
}

function measureTime(callback, arr) {
  const start = Date.now();
  const result = callback(arr);
  const end = Date.now();
  return [end - start, result];
}

let arrLength = Array.from({ length: 10000 }, (_, k) => 10000 - k);

// 첫번째 코드 시간 측정
// 첫번째 코드 실행 시간 : 2081ms
const [bubbleTime, bubbleResult] = measureTime(bubbleSort, arr);
console.log(`첫번째 코드 실행시간: ${bubbleTime}ms`);

// 두번째 코드 시간 측정
// 두번째 코드 실행 시간: 1ms
arr = Array.from({ length: 10000 }, (_,k) => 10000 - k);
const [doSortTime, doSortResult] = measureTime(doSort, arr);
console.log(`두번째 코드 실행시간: ${doSortTime}ms`);

// 첫번째 방법은 O(N^2) 정렬 알고리즘인 버블 정렬을 활용한 방법이고, 두번째 방법은 O(NlogN) 시간 복잡도의 sort() 함수를 활용한 방법입니다. 결과를 보면 시간 차가 상당합니다. 데이터 10,000개를 역순으로 정렬하는 데 버블 정렬은 2초가 걸렸지만 sort() 함수를 활용한 두번째 방법은 1밀리초 밖에 걸리지 않았습니다. 실행환경마다 시간의 차이는 조금 생길수 있겠지만 압도적으로 sort() 함수가 성능이 좋다는 것을 알수 있습니다. 이것으로 알고리즘의 시간 복잡도가 얼마나 중요한지 알아두기 바랍니다.

// 문제 02 배열 제어하기
// 제약 조건
// 배열 길이는 2 이상 1,000 이하입니다.
// 각 배열의 데이터 값은 -100,000 이상 100,000 이하입니다.

function 배열제어하기(arr) {
  const uniqueArr = [...new Set(arr)];
  uniqueArr.sort((a,b) => b - a);
  return uniqueArr;
}
// Set 객체는 해시 알고리즘으로 데이터를 저장하므로 시간 복잡도 O(N)을 보장합니다.

// 시간 복잡도 분석하기
// N은 arr의 길이입니다. arr의 중복 원소를 제거하는 데 걸리는 시간 복잡도는 O(N)이고, 이를 다시 정렬하는 데 걸리는 시간 복잡도는 O(NlogN)이므로 최종시간 복잡도는 O(NlogN)입니다.

// 문제03 두 개 뽑아서 더기
// 권장 시간 복잡도_O(N^2log(N^2))
// 정수 배열 numbers에서 서로 다른 인덱스에 있는 2개의 수를 뽑아 더 해 만들수 있는 모든 수를 배열에 오름차순으로 담아 반환하는 solution() 함수를 완성하세요.

// 제약 조건
// numbers의 길이는 2 이상 100이하입니다. 모든 수는 0이상 100이하입니다.

// 문제 분석
// 중복값은 허용하지 않는다.
// 1. 배열에서 두 수를 선택하는 모든 경우의 수를 구한다. => 두수를 선택하는 방법은 다음 그림처럼 각 수에서 자신보다 뒤에 있는 수를 선택하면 됩니다.
// 2. 과정 1에서 구한 수를 새로운 배열에 저장하고 중복값을 제거한다. => 
// 3. 배열을 오름차순으로 정렬하고 반환한다.

function 두개뽑아서더하기(numbers) {
  const ret = [];  // 빈 배열 생성
  // numbers 데이터에서 반복문으로 두 수를 선택하는 경우의 수를 구함
  for (let i = 0; i < numbers.length; i++) {
    for (let j =0; j < i; j++) {
      // 두수를 더한 결과를 새로운 배열에 추가
      ret.push(numbers[i] + numbers[j]);
    }
  }
  return [...new Set(ret)].sort((a, b) => a - b);
}

// 1. ret 배열은 값을 추가하기 위한 배열입니다. 초 상ㅐ이므로 아무 데이터도 없습니다.
// 2. numbers 의 데이터에서 두 수를 선택하는 반복문
// 예를 들어, i = 0, j = 2인 경우 {5, 2} => 7이라고 표시했습니다. 
// push() 메서드로 ret ㅂ열에 추가합니다. 중복값을 제거하기 전입니다.
// 이후 Set 객체로 중복값을 제거한후 sort() 메서드를 통해 오름차순으로 정렬해 반환합니다.

// 시간 복잡도 분석하기
// N은 numbers의 길이입니다. 모든 조합을 확인하는 과정에서 중복을 체크하는데 O(N^2)이 걸립니다. 그리고 이를 정렬하는데 O(N2log(N^2))이 걸리므로 최종시간 복잡도는 O(N^2log(N2))입니다.

// 수포자 삼인방 중 수학 문제를 찍어서 가장 많응ㄴ 문제를 맞힌 사람이 누구인지 배ㄹ에 담아 반환하도록 solution() 함수 작성하기
// 문제 분석하기
// 가장 먼저 해야할 일은 수포자들의 문제 찍는 패턴을 분석하는 것입니다. 반복되는 패턴을 찾습니다. 그리고 각 패턴으로 문제를 풀 경우 몇개를 맞출 수 있는지 체크합니다. 문제 번호에 대해 수포자의 답과 실제 답이 일치할 때마다 점수를 획득하는데, 이 점수가 가장 큰 수포자를 찾습니다.
function 수포자(answers) {
  // 수포자들의 패턴
  const patterns = [
    [1, 2, 3, 4, 5],  // 수포자1
    [2, 1, 2, 3, 2, 4, 2, 5],  // 수포자2
    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5],
  ];
  // 수포자들의 점수를 저장할 배열
  const scores = [0, 0, 0];
  // 각 수포자의 패턴과 정답이 얼마나 일치하는지 확인
  for (const [i, answer] of answers.entries()) {
    for (const [j, pattern] of patterns.entries()) {
      if (answer === pattern[i % pattern.length]) {
        scores[j] += 1;
      }
    }
  }

  // 가장 높은 점수 저장
  const maxScore = Math.max(...scores);

  // 가장 높은 점수를 받은 수포자들의 번호를 찾아서 배열에 담음
  const highestScores = [];
  for (let i = 0; i < scores.length; i++) {
    if (scores[i] === maxScore) {
      highestScores.push(i + 1)
    }
  }
  return highestScoresl
}

// 시간 복잡도 분석하기
// N은 answers의 길이입니다. 각 수포자들의 패턴과 정답을 비교하는 부분은 O(N)입니다. 이후 scores를 순회하면서 가장 높은 점수를 받은 수포자를 추가하는 연산은 O(1)입니다. 따라서 최종 시간 복잡도는 O(N)입니다.

// 문제 05. 2차원 행렬 arr1과 arr2를 입력받아 arr1에 arr2를 곱한 결과를 반환하는 solution() 함수를 완성하세요.

// 문제 분석하기
// 수학의 행렬 곱셈을 그대로 구현하면 됩니다. 두 배열의 최대 데이터 개수가 100개이므로 시간 복잡도는 신경쓰지 않아도 됩니다. 또한 곱할 수 있는 배열만 주어지므로 예외 처리도 없습니다.
function 행렬의곱셈(arr1, arr2) {
  // 행렬 arr1과 arr2의 행과 열의 수 
  const r1 = arr1.length;
  const c1 = arr1[0].length;

  // 결과를 저장할 2차원 배열 초기화
  const ret = [];
  for (let i = 0; i < r1; i++) {
    ret.push(new Array(c2).fill(0));
  }

  // 첫번째 행렬 arr1의 각 행과 두번째 행렬 arr2의 각 열에 대해
  for (let i = 0; i < r1; i++) {
    for (let j = 0; j < c2; j++) {
      // 두 행렬의 데이터를 곱해 결과 배열에 더해줌
      for (let k = 0; k < c1; k++) {
        ret[i][j] += arr1[i][k] * arr2[k][j];
      }
    }
  }
  return ret;
}

// 문제를 나누는 연습을 해보기 좋습니다. 행렬 곱셈에서 가장 먼저 행렬 곱셈의 결괏값을 어떻게 저장할지 고려해야합니다. 결괏값을 저장하려면 두 행렬을 곱했을 때 결과 행렬의 크기를 알아야 합니다. 이건 행렬 정의를 안다면 ㅜ십게 해결할 수 있습니다.
// 1. 인수로 받은 arr1과 arr2의 행과 열 정보를 변수에 기록합니다. 이후 행렬 정의를 활용해서 결과 행렬을 저장할 수 있는 크기의 새 행렬을 만들고 모든 데이터를 0으로 초기화합니다.
// 2. 결과 행렬의 크기는 r1 * c2)이므로 해당 크기의 배열을 미리 만들어 0으로초기화합니다. 즉 ret에는 행렬 곱 결과가 저장됩니다.
// 3. arr1고ㅏ arr2의 행렬을 곱하기 위한 반복문을 작성합니다. 행렬을 곱할 땐 첫번째 행렬의 각 행과 두번째 행렬의 각 열들을 매치해 연산합니다. 이를 위해 반복문에서 첫번째 행렬의 행의 크기인 r1과 두번째 행렬의 열의 크기인 c2를 사용했습니다.
//  

// 시간 복잡도 분석하기
// N은 행 혹은 열의 길이입니다. 행과 열의 길이는 같습니다. arr1의 행과 열 수를 r1, c1라고 하고, arr2의 행과 열 수 를 r2, c2라고 했을 때 r1 * c1 * c2만큼 연산합니다. r1, c1, r2, c2 모두 N으로 볼 수 있으므로 최종시간 복잡도는 O(N^2)입니다.

// 06 실패율
// 실패율 정의: 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의수 / 스테이지에 도달한 플레이어의 수
// 첫번째 입출력 예: 1번 스테이지에는 총 8명의 사용자가 도전했고 1명이 클리어하지 못함 -> 1번 스테이지 실패율: 1/8
// 2번 스테이지: 총 7명의 사용자가 도전했으며, 3명의 사용자가 클리어하지 못함 -> 2번 스테이지 실패율: 3/7
// 3번 스테이지: 2/4
// 4번 스테이지: 1/2
// 5번 스테이지: 0/1
function 실패율(N, stages) {
  // 1. 스테이지별 도전자 수를 구함
  const challenger = new Array(N + 2).fill(0);
  for (const stage of stages) {
    challenger[stage] += 1;
  }
  // 2. 스테이지별 실패한 사용자 수 계산
  const fails = {};
  let total = stages.length;

  // 각스테이지를 순회하며, 실패율 계산
  for (let i = 1; i <= N; i++) {
    if (challenger[i] === 0) {
      // 4. 도전한 사람이 없는 경우, 실패율은 0
      fails[i] = 0;
      continue;
    }

    // 5. 실패율 계산
    fails[i] = challenger[i] / total;

    // 6. 다음 스테이지 실패율을 구하기 위해 현재 스테이지의 인원을 뺌
    total -= challenger[i];
  }
  // 7. 실패율이 높은 스테이지부터 내림차순으로 정렬
  const result = Object.entries(fails).sort((a, b) => b[1] - a[1]);

  // 8. 스테이지 번호만 반환
  return result.map((v) => Number(v[0]));
}

// 1. caleenger에 스테이지에 도전하는 사용자수를 저장. 배열의 킉를 N + 2로 정한 이유 -> N번째 스테이지를 클리어한 사용자는 stage가 N+1dlamfh challenger 배열에서 N+1 위치에 데이터를 저장해야 ㅎ나ㅡㄴ데 배열의 인덱스는 0부터 시작이므로 N+1 인덱스에 데이터를 저장하려면 N+2 크기의 배열이 필요하기 때문입니다. 이렇게 하면 값 자체를 인덱스로 활용할 수 있어 매우 편리합니다.
// 5. fails는 배열이 아니고 객체라는 것을 기억해야합니다.

// 시간 복잡도
// N은 스테이지의 개수이고, M은 stages의 길이입니다. challenger 배열을 초기화하고, 각 스테이지 도전자 수를 계산할 때 시간 복잡도는 O(N + M) 입니다. 이후 스테이지 별로 실패율을 계산하는 데 필욯나 시간 복잡도는 O(N)이고, 실패율을 기준으로 스테이지를 정렬할 때으 ㅣ시간 복잡도는 O(NlogN)입니다. 이 연산들을 모두 고려하면 시간 복잡도는 O(2*N + M + NlogN)이므로 최종 시간 복잡도는 O(M + NlogN)입니다.

// 07 방문 길이 
// 이 문제는 명령어대로 로봇이 이동할 때 중복 경로의 길이를 제외한 움직인 경로의 길이를 반환해야 합니다. 
// 유의할 점
// 1. 중복 경로는 최종 길이에 포함하지 않는다는 조건입니다. 
// 2. 음수 좌표를 포함한다는 점입니다. 2차원배열에서 음수 인덱스를 사용할 수 는 없으므로 다른 방법을 생각해야 합니다. 좌표는 방향에 의해서만 제어되므로 원점을 (0, 0)에서 (5, 5)로 바꿔 음수 좌표 문제를 해결해도 됩니다.

function isValidMove(nx, ny) {
  return nx >= -5 && nx <= 5 && ny >= -5 && ny <= 5;  // 좌표평면을 벗어나는지 체크하는 함수를 핵심 알고리즘과 분리
}

function updateLocation(x, y, dir) {  // 다음 좌표 결정
  switch (dir) {  // 현재 좌표의 방향 dir
    case "U":
      return [x, y+1];
    case "D":
      return [x, y-1];
    case "R":
      return [x+1, y];
    case "L":
      return [x-1, y];
  }
}

function 방문길이(dirs) {
  let x = 0;
  let y = 0;

  const visited = new Set();  // 이미 지난 좌표(중복)는 Set 함수로 1개로 처리
  for (const dir of dirs) {
    // updateLocation의 명령어로 움직이면서 좌표 저장
    const [nx, ny] = updateLocation(x, y, dir);

    if (!isValidMove(nx, ny)) {
      // 벗어난 좌표는 인정하지 않음
      continue;
    }

    // A -> B로 간 경우 B -> A도 추가하고 나중에 최종 이동 길이를 2로 나눔
    // 총 경로의 개수는 방향성이 없음
    visited.add(`${x}${y}${nx}${ny}`);  // '(x,y)에서 (nx, ny)까지의 경로를 방문했다'고 기록하는 것을 의미함
    visited.add(`${nx}${ny}${x}${y}`);

    [x, y] = [nx, ny];  // 좌표 업데이트
  }
  return visited.size / 2;
}