// 배열 개념
const arr1 = new Array(6);
const arr2 = [...new Array(6)].map((_, i) => i + 1);

const arr = new Array(6).fill(0);
const arr3 = [...new Array(4)].map((_,i) => new Array(4).fill(i));

/**배열 연산의 시간 복잡도
 * 배열은 임의 접근이라는 방법으로 배열의 모든 위치에 있는 데이터에 단 한 번에 접근할 수 있다. 
 * 따라서 데이터에 접근하기 위한 시간 복자도는 O(1).
 * 배열에 데이터를 추가하는 경우에는 배열은 데이터를 어디에 저장하느냐에 따라 추가 연산에 대한 시간 복잡도가 달라진다.
 * 
 * 맨 뒤에 삽입할 경우 arr[3]에 임의 접근으 ㄹ바로 할 수 있으며 데이터를 삽입해도 다른 데이터 위치에 영향을 주지 않습니다. 따라서 시간 복잡도는 O(1)입니다.
 * 
 * 배열을 선택할 때 고려할 점
 * 데이터에 자주 접근하거나 읽어야하는 경우 배열을 사용하면 좋은 성능을 낼 수 있습니다.
 * 예를 들어 그래프를 표현할 때 임의 접근을 할 수 있으므로 간선 여부도 시간 복잡도 O(1)로 판단할 수 있습니다. 
 * 하지만 배열은 메모리 공간을 충분히 확보해야하는 단점도 있습니다.
 * 
 * 따라서 코딩 테스트에서는 다음 사항을 고려해 배열을 선택해야합니다.
 * 1. 할당할 수 있는 메모리 크기를 확인해야 합니다.
 * 배열로 표현하려는 데이터가 너무 많으면 런타임에서 배열할당에 실패할 수 있습니다. 운영체제마다 배열을 할당할 수 있는 메모리의 한계치는 다르지만  보통은 정수형 1차원 배열은 1000만 개, 2차원 배열은 3000*3000 크기를 최대로 생각합니다.
 * 2. 중간에 데이터 삽입이 많은지 확인해야 합니다.
 * 배열은 선형 자료 구조이기 때문에 중간이나 처음에 데이터를 빈번하게 삽입하면 시간 복잡도가 높아져 실제 시험에서 시간 초과가 발생할 수 있습니다.
*/

/** 스프레드 연산자로 데이터 추가 */
let spreadArr = [1,2,3];
spreadArr = [...spreadArr, ...[4, 5]];

// unshift() 메서드로 데이터 추가
const unshiftArr = [1, 2, 3];
unshiftArr.unshift(0);

// splice() 메서드로 데이터 추가
// 배열 중간에 데이터를 추가하기 위해서는 splice() 메서드를 사용해야 합니다. 
// array.splice(start[, deleteCount[, item1[, item2[, ...]]]])
// 첫번째 매개변수 start 는 배열 내 시작 지점을 의미합니다. 두번째 매개변수 deleteCount는 삭제할 데이터의 수를 의미하고
// 이후로는 추가할 데이터를 받습니다. 
// 이를 이용하여 두번째 매개변수를 0으로 설정하면 다음과 같이 중간에 데이터를 추가할 수 있습니다. 
/// 대괄호로 감싸지 않은 첫번째 매개변수는 꼭 필요한 값이고, 대괄호로 감싼 매개변수는 선택 optional 매개변수입니다.
//

// 배열 몸풀기 문제 - 배열 정렬하기
// 권장 시간 복잡도 O(NlogN)
// 정수 배열의 길이는 2 이상 10^5 이하입니다.
// 정수 배열의 각 데이터 값은 -100,000 이상 100,000 이하입니다.
// 문제만 놓고 보면 가단해 보이지만 제약 조건을 주의 깊게 봐야합니다. 제약 조건을 보면 데이터 개수는 최대 10^%입니다.
// 즉, 제한 시간이 3초라면 O(N^2) 알고리즘을 사용해도 되죠. 제가 이 문제를 제시한 이유는 제약 조건에 따른 알고리즘의 선택을 보여주기 위함입니다. 

function solution(arr) {
  arr.sort((a, b) => a - b);
  return arr;
}
// 첫번째 인자 a가 두번째 인자 b보다 앞에 나와야 한다면 음수를 반환한다.
// 첫번째 인자 a가 두번째 인자 b보다 뒤에 나와야 한다면 양수를 반환한다.
// 3. 위치 변경을 하지 않는다면 0을 반환한다.

// 먼저 기준은 첫번째 인수라는 점을 이용할 수 있습니다. 따라서 첫번째 인자를 a, 두번째 인자를 b라고 부를때 
// a에서 b를 빼는 식을 사용한다면 a가 b보다 큰 경우 자연스럽게 양수가 반환되고 작은 경우엔 음수가 ㅏㄴ환됩니다.
// 만약 반대로 내림차순으로 정렬한다면 두번째 인자에서 첫번째 인자를 빼도록 만들면 됩니다.
// 참고로 sort() 메서드를 사용하면 기존 ㅐ열이 변경됩니다. 원본 배열을 그대로 두고 싶다면 toSorted() 메서드를 사용할 수도 있지만 비교적 최근에 추가된 기능이므로 sort() 메서드 사용을 추천합니다.

// sort() 메서드를 사용하지 않고 O(N^2) 정렬 알고리즘을 사용하면?
function bubbleSort(arr) { // 버블 정렬을 활용한 방법
  const n = arr.length;
  for (let i = 0; i < n; i++){
    for (let j = 0; j < n - i - 1; j++){
      if (arr[j + 1] < arr[j]) {
        const tmp = arr[j + 1];
        arr[j + 1] = arr[j];
        arr[j] = tmp;
      }
    }
  }
  return arr;
}

function doSort(arr) {  // sort() 함수를 활용한 방법
  arr.sort((a, b) => a - b);
  return arr;
}

function measureTime(callback, arr) {
  const start = Date.now();
  const result = callback(arr);
  const end = Date.now();
  return [end - start, result];
}

let arrLength = Array.from({ length: 10000 }, (_, k) => 10000 - k);

// 첫번째 코드 시간 측정
// 첫번째 코드 실행 시간 : 2081ms
const [bubbleTime, bubbleResult] = measureTime(bubbleSort, arr);
console.log(`첫번째 코드 실행시간: ${bubbleTime}ms`);

// 두번째 코드 시간 측정
// 두번째 코드 실행 시간: 1ms
arr = Array.from({ length: 10000 }, (_,k) => 10000 - k);
const [doSortTime, doSortResult] = measureTime(doSort, arr);
console.log(`두번째 코드 실행시간: ${doSortTime}ms`);

// 첫번째 방법은 O(N^2) 정렬 알고리즘인 버블 정렬을 활용한 방법이고, 두번째 방법은 O(NlogN) 시간 복잡도의 sort() 함수를 활용한 방법입니다. 결과를 보면 시간 차가 상당합니다. 데이터 10,000개를 역순으로 정렬하는 데 버블 정렬은 2초가 걸렸지만 sort() 함수를 활용한 두번째 방법은 1밀리초 밖에 걸리지 않았습니다. 실행환경마다 시간의 차이는 조금 생길수 있겠지만 압도적으로 sort() 함수가 성능이 좋다는 것을 알수 있습니다. 이것으로 알고리즘의 시간 복잡도가 얼마나 중요한지 알아두기 바랍니다.

// 문제 02 배열 제어하기
// 제약 조건
// 배열 길이는 2 이상 1,000 이하입니다.
// 각 배열의 데이터 값은 -100,000 이상 100,000 이하입니다.

function 배열제어하기(arr) {
  const uniqueArr = [...new Set(arr)];
  uniqueArr.sort((a,b) => b - a);
  return uniqueArr;
}
// Set 객체는 해시 알고리즘으로 데이터를 저장하므로 시간 복잡도 O(N)을 보장합니다.

// 시간 복잡도 분석하기
// N은 arr의 길이입니다. arr의 중복 원소를 제거하는 데 걸리는 시간 복잡도는 O(N)이고, 이를 다시 정렬하는 데 걸리는 시간 복잡도는 O(NlogN)이므로 최종시간 복잡도는 O(NlogN)입니다.

// 문제03 두 개 뽑아서 더기
// 권장 시간 복잡도_O(N^2log(N^2))
// 정수 배열 numbers에서 서로 다른 인덱스에 있는 2개의 수를 뽑아 더 해 만들수 있는 모든 수를 배열에 오름차순으로 담아 반환하는 solution() 함수를 완성하세요.

// 제약 조건
// numbers의 길이는 2 이상 100이하입니다. 모든 수는 0이상 100이하입니다.

// 문제 분석
// 중복값은 허용하지 않는다.
// 1. 배열에서 두 수를 선택하는 모든 경우의 수를 구한다. => 두수를 선택하는 방법은 다음 그림처럼 각 수에서 자신보다 뒤에 있는 수를 선택하면 됩니다.
// 2. 과정 1에서 구한 수를 새로운 배열에 저장하고 중복값을 제거한다. => 
// 3. 배열을 오름차순으로 정렬하고 반환한다.

function 두개뽑아서더하기(numbers) {
  const ret = [];  // 빈 배열 생성
  // numbers 데이터에서 반복문으로 두 수를 선택하는 경우의 수를 구함
  for (let i = 0; i < numbers.length; i++) {
    for (let j =0; j < i; j++) {
      // 두수를 더한 결과를 새로운 배열에 추가
      ret.push(numbers[i] + numbers[j]);
    }
  }
  return [...new Set(ret)].sort((a, b) => a - b);
}